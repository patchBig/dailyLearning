# 浏览器缓存

## 强制缓存

浏览器加载资源，先直接从缓存中查找请求结果，如果不存在，则直接向服务端发起请求。

1. Expires

客户端第一次请求时，服务端会在响应头部添加 Expires 字段；再次发起请求时，会对比当前时间和 Expires 对应时间

2. Cache-Control

- no-cache，表示使用协商缓存，即每次使用缓存之前必须向服务端确认缓存资源是否更新
- no-store，禁止浏览器和所有中间缓存响应内容。
- public，共有缓存，可以被代理服务器缓存，可以被多个用户共享
- private，私有缓存，不能被代理服务缓存，和共有缓存相反
- max-age，以秒为单位的数值，表示缓存的有效时间
- must-revalidate，当缓存过期时，需要去服务器校验缓存的有效性

## 协商缓存

浏览器直接发送请求到服务端进行确认缓存是否更新，响应返回的 http 状态为 304 则表示缓存有效，缓存控制由浏览器转移到服务端

1. last-modified 和 If-Modified-since

通过响应头部字段 last-Modified 和请求头部字段 If-Modified-since 对比双方资源的修改时间

精度问题：
Last-Modified 精度为秒，如果一秒内发生更改，则缓存判断可能会失效

准度问题：
如果一个文件 revert 操作，浏览器的缓存还是可用的，但是修改四件发生变化，也会重新返回重复内容

2. ETag 和 If-None-Match

响应头部字段 ETag 和请求字段 If-None-Match；无论是否发生变化，都会将计算出的哈希值放到响应头部的 ETag 字段中。

- 计算成本
生成 hash 相对于读取文件修改时间而言是一个开销较大的操作，尤其是对于大文件而言，如果要精确计算则需读取完整的文件内容。
- 计算误差
不同服务器可能会采用不同的哈希值计算方式，会导致同一个资源在两台服务器产生的 ETag 可能是不相同的，所以对于使用服务器集群来处理请求的网站来说，使用 ETag 的缓存命中率会有所降低。

## 总结

强缓存就是在缓存的有效期内直接使用浏览器缓存
协商缓存则需要先询问服务端资源是否发生改变，如果未改变再使用浏览器缓存
ServiceWorker 可以用来实现离线缓存，主要原理是拦截浏览器请求并返回缓存的资源文件
